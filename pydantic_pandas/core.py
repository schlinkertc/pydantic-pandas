# AUTOGENERATED! DO NOT EDIT! File to edit: 00_core.ipynb (unless otherwise specified).

__all__ = ['TypedFrame', 'TypedArray', 'ArrayMeta', 'Array', 'conarray', 'PandasDataFrame', 'DataFrameModelMetaclass',
           'BaseFrame']

# Internal Cell

from pandas.core.frame import DataFrame as PandasDataFrame
from pydantic import (
    validator,
    root_validator
)
from pydantic import BaseModel as PydanticBaseModel
from pydantic.main import ModelMetaclass
from .default_standard_lib import *
from .utils import delegates
from IPython.display import JSON

# Internal Cell
from typing import Any
from pandas.api.types import pandas_dtype
from pydantic.utils import update_not_none

class TypedArray(pd.Series):
    dtype: Any = np.object_

    @classmethod
    def __get_validators__(cls):

        yield cls.validate_array

    @classmethod
    def __modify_schema__(cls, field_schema: Dict[str, Any]) -> None:

        update_not_none(
            field_schema,
            type='Numpy Array',
            inner_type = cls.dtype
        )

    @classmethod
    def validate_array(cls, array):
        dtype = cls.dtype

        if dtype == dt.date or dtype==dt.datetime or dtype=='datetime64':
            dtype = pandas_dtype('datetime64[ns]')

        return pd.Series(array,dtype=pandas_dtype(dtype))


#exporti

class ArrayMeta(type):
    def _ipython_key_completions_(self):
        return _key_completions_

    def __getitem__(self, dtype):

        return type('ConstrainedArray', (TypedArray,), {'dtype': dtype})


#exporti

class ConstrainedArray(DataFrame, metaclass=ArrayMeta):
    pass

# Internal Cell

from typing import Dict, Any, Type
from pydantic import ValidationError
def update_not_none(mapping: Dict[Any, Any], **update: Any) -> None:
    mapping.update({k: v for k, v in update.items() if v is not None})

# Cell

class TypedFrame(DataFrame):
    columns: Optional[list] = None
    row_model: Optional[Type[BaseModel]] = None

    @classmethod
    def __get_validators__(cls):
        yield cls.validate_columns
        yield cls.validate_rows

    @classmethod
    def __modify_schema__(cls, field_schema: Dict[str, Any]) -> None:
        row_model=None
        if cls.row_model:
            row_model = cls.row_model.schema()
        update_not_none(
            field_schema,
            columns=cls.columns,
            row_model=row_model
        )
    @classmethod
    def validate_columns(cls,df):
        if cls.columns:
            for c in cls.columns:
                if c not in df.columns:
                    raise ValueError(f"{c} not found in columns index: {df.columns}")
        return df

    @classmethod
    def validate_rows(cls, df):

        if cls.row_model:
            parsed = []

            for record in df.to_dict('records'):
                try:
                    model = cls.row_model.parse_obj(record)
                    parsed.append(model.dict())
                except ValidationError as e:

                    if hasattr(cls.row_model.Config,'on_error'):
                        if cls.row_model.Config.on_error=='skip':
                            continue
                    raise e

            return pd.DataFrame.from_records(parsed)
        return df

# Internal Cell

class FrameMeta(type):
    def __getitem__(self, constraint):
        if type(constraint)==tuple:
            return type('ConstrainedFrame', (TypedFrame,), {'columns': constraint})
        elif hasattr(constraint,'__get_validators__'):
            return type('ConstrainedFrame', (TypedFrame,), {'row_model': constraint})
        else:
            raise NotImplementedError(f"The constraint you provided is to compatible with the 'TypedFrame' Object. {constraint} ")


#exporti

class ConstrainedFrame(DataFrame, metaclass=FrameMeta):
    pass

# Internal Cell

def conframe(
    *,
    columns: list = None,
    row_model: Type[BaseModel] = None
) -> Type[DataFrame]:
    # use kwargs then define conf in a dict to aid with IDE type hinting
    namespace = dict(columns=columns,row_model=row_model)
    return type('ConstrainedFrameValue', (ConstrainedFrame,), namespace)

# Cell

class TypedArray(pd.Series):

    @classmethod
    def __get_validators__(cls):
        yield cls.validate_type

    @classmethod
    def __modify_schema__(cls,field_schema:Dict)->Dict:
        field_schema.update(
            type="<Pandas Series>"
        )

    @classmethod
    def validate_type(cls,val):
        print('validating array')
        print(val)
        return cls(val)

class ArrayMeta(type):
    def __getitem__(self,t):
        return type('Array', (TypedArray,), {'inner_type':t})

class Array(pd.Series,metaclass=ArrayMeta):
    pass

def conarray(*args,**kwargs) -> Type[TypedArray]:

    return type('ConstrainedArray',(TypedArray,), kwargs)

# Cell

class PandasDataFrame(DataFrame):
    """
    Pandas DataFrame Validation
    """

    @classmethod
    def __get_validators__(cls):
        # one or more validators may be yielded which will be called in the
        # order to validate the input, each validator will receive as an input
        # the value returned from the previous validator
        yield cls.validate

    @classmethod
    def __modify_schema__(cls, field_schema):
        # __modify_schema__ should mutate the dict it receives in place,
        # the returned value will be ignored
        field_schema.update(
            type='Pandas DataFrame'
        )

    @classmethod
    def validate(cls, v):
        if not isinstance(v, pd.DataFrame):
            raise TypeError(f'Dataframe required. Got {type(v)} instead')
        if v.empty:
            raise ValueError("Dataframe can't be empty")
        return v
    def __init__(self,*args,**kwargs):
        print('making the pandas data frame')
        super(PandasDataFrame,self).__init__(*args,**kwargs)

# Internal Cell

DataFrameModelMetaclass = ForwardRef('DataFrameModelMetaclass')

def extract_ddf_from_model_fields(model:ModelMetaclass) -> 'PandasDataFrame':
    """Returns default df for DataFrameModelMetaclass ._repr_html_() method"""
    d={}
    for k,v in model.__fields__.items():
        d[k]=[v.required,v.type_]
    return pd.DataFrame(d,index=['required','type'])

# Cell

class DataFrameModelMetaclass(ModelMetaclass):
    def __new__(cls,name,bases,dct):
        print("in DF Meta __new__")
        print(name)
        print(bases)

        d = dct.get('__annotations__')
        if d:
            d = {k:conarray(v) for k,v in d.items()}
            dct['__annotations__']=d
        print(dct)
        model = ModelMetaclass.__new__(cls,name,bases,dct)
        model._default_df_ = extract_ddf_from_model_fields(model)

        return model
#     def __getitem__(self,t):
#         return type('Array', (TypedArray,), {'inner_type':t})

#     def _repr_json_(cls):

#         both_schemas = dict(
#             pandas_schema = json.loads(cls._default_df_.to_json()),
#             pydantic_schema = cls.schema()
#         )
#         return both_schemas

    def _repr_html_(cls):
        return cls._default_df_.to_html()

class BaseFrame(PydanticBaseModel,PandasDataFrame,metaclass=DataFrameModelMetaclass):
    """Doc from BaseFame"""
    def __init__(self,*args,**kwargs):
        print("base frame init")
        super(BaseFrame,self).__init__(**kwargs)
        super(PandasDataFrame,self).__init__(self.dict())

    @root_validator()
    def _base_frame_root_validator(cls,values):
        print('In Base Frame Root validator')
        return values
